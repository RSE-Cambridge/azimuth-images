#!/usr/bin/env python3

import json
import os
import pathlib

import requests
import ruamel.yaml

import easysemver


RELEASES_URL = "https://api.github.com/repos/kubernetes/kubernetes/releases"


def github_request(url):
    """
    Makes a request to the GitHub API, injecting the token if available.
    """
    headers = { "Content-Type": "application/json" }
    if "GITHUB_TOKEN" in os.environ:
        headers["Authorization"] = f"Bearer {os.environ['GITHUB_TOKEN']}"
    return requests.get(url, headers = headers)


def k8s_latest_version():
    """
    Returns the latest Kubernetes version.
    """
    response = github_request(f"{RELEASES_URL}/latest")
    response.raise_for_status()
    return easysemver.Version(response.json()["tag_name"])


def k8s_latest_version_for_series(series):
    """
    Returns the latest Kubernetes version for the given series.
    """
    # Using a tilde range allows flexibility in the patch version
    range = easysemver.Range(f"~{series}.0")
    # Return the first version that matches the range
    next_url = RELEASES_URL
    while next_url:
        response = github_request(next_url)
        response.raise_for_status()
        for release in response.json():
            try:
                version = easysemver.Version(release["tag_name"])
            except TypeError:
                continue
            if version in range:
                return version
        next_url = response.links.get("next", {}).get("url")


def update_vars_file(vars_file, version):
    """
    Updates the specified vars file to the given version.
    """
    data = {
        "kubernetes_deb_version": f"{version.format(prefix = False)}-00",
        "kubernetes_rpm_version": f"{version.format(prefix = False)}-0",
        "kubernetes_semver": str(version),
        "kubernetes_series": f"{version.prefix}{version.major}.{version.minor}",
    }
    with vars_file.open("w") as fh:
        json.dump(data, fh, indent = 4)


def update_existing_vars_files(repo_root):
    """
    Updates the existing vars files to the most recent patch version.
    """
    vars_files_dir = repo_root / "vars" / "base"
    for vars_file in vars_files_dir.glob("kubernetes_*.json"):
        with vars_file.open() as fh:
            data = json.load(fh)
        # Get the latest version for the series and update the file
        latest_version = k8s_latest_version_for_series(data["kubernetes_series"])
        update_vars_file(vars_file, latest_version)


def create_env_file(repo_root, version, vars_file):
    """
    Create an env file for the specified version.
    """
    env_file = repo_root / "env" / "base" / f"kubernetes_{version.major}_{version.minor}.env"
    with env_file.open("w") as fh:
        fh.write(f"PACKER_VAR_FILES=\"$PACKER_VAR_FILES,{vars_file.relative_to(repo_root)}\"")


BUILD_TEMPLATE = """

name: kubernetes-{major}-{minor}-{distro}
template: kubernetes
var-files: common,kvm,linux,ubuntu-{distro},kubernetes,kubernetes_{major}_{minor}
path-filters: |
  paths:
    - .github/workflows/pr.yml
    - bin/*
    - config.pkr.hcl
    - requirements.yml
    - env/*/common.env
    - env/*/kvm.env
    - env/*/linux.env
    - env/*/ubuntu-{distro}.env
    - env/*/kubernetes.env
    - env/*/kubernetes_{major}_{minor}.env
    - vars/*/common.json
    - vars/*/kvm.json
    - vars/*/linux.json
    - vars/*/ubuntu-{distro}.json
    - vars/*/kubernetes.json
    - vars/*/kubernetes_{major}_{minor}.json
    - packer/kubernetes.pkr.hcl
    - vendor/image-builder/**
"""


def add_build_entries(repo_root, version):
    """
    Add build entries for the specified Kubernetes version.
    """
    yaml = ruamel.yaml.YAML(typ = "rt")
    yaml.preserve_quotes = True
    yaml.width = 1000000
    yaml.mapping_indent = 2
    yaml.sequence_indent = 2
    yaml.sequence_dash_offset = 0

    path = repo_root / ".github" / "builds.yaml"

    with path.open() as fh:
        builds = yaml.load(fh)

    # Add a build for focal and a build for jammy
    builds.extend([
        yaml.load(
            BUILD_TEMPLATE.format(
                distro = distro,
                major = version.major,
                minor = version.minor
            )
        )
        for distro in ["focal", "jammy"]
    ])

    with path.open("w") as fh:
        yaml.dump(builds, fh)


def main():
    # Get the repository root
    repo_root = pathlib.Path(__file__).parent.parent.resolve()

    # Update the existing vars files to the most recent patch version
    update_existing_vars_files(repo_root)

    # Get the latest Kubernetes version
    latest_version = k8s_latest_version()
    # Check if a vars file exists for it
    latest_filename = f"kubernetes_{latest_version.major}_{latest_version.minor}.json"
    latest_vars_file = repo_root / "vars" / "base" / latest_filename
    # If it does, we are done
    if latest_vars_file.exists():
        return
    # If no vars file exists, it is a new version that we have not seen before
    # We need to set up builds for it
    #   vars file
    update_vars_file(latest_vars_file, latest_version)
    #   env file
    create_env_file(repo_root, latest_version, latest_vars_file)
    #   build entries
    add_build_entries(repo_root, latest_version)


main()
